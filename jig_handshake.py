#!/usr/bin/env python
'''

PSP v8 Syscon Handshake Calculator by Proxima (R)

'''
from Crypto.Cipher import AES
import os
from random import randbytes



keystore = {
0: [0x5C, 0x52, 0xD9, 0x1C, 0xF3, 0x82, 0xAC, 0xA4, 0x89, 0xD8, 0x81, 0x78, 0xEC, 0x16, 0x29, 0x7B],
1: [0x9D, 0x4F, 0x50, 0xFC, 0xE1, 0xB6, 0x8E, 0x12, 0x09, 0x30, 0x7D, 0xDB, 0xA6, 0xA5, 0xB5, 0xAA],
2: [0x09, 0x75, 0x98, 0x88, 0x64, 0xAC, 0xF7, 0x62, 0x1B, 0xC0, 0x90, 0x9D, 0xF0, 0xFC, 0xAB, 0xFF],
3: [0xC9, 0x11, 0x5C, 0xE2, 0x06, 0x4A, 0x26, 0x86, 0xD8, 0xD6, 0xD9, 0xD0, 0x8C, 0xDE, 0x30, 0x59],
4: [0x66, 0x75, 0x39, 0xD2, 0xFB, 0x42, 0x73, 0xB2, 0x90, 0x3F, 0xD7, 0xA3, 0x9E, 0xD2, 0xC6, 0x0C],
5: [0xF4, 0xFA, 0xEF, 0x20, 0xF4, 0xDB, 0xAB, 0x31, 0xD1, 0x86, 0x74, 0xFD, 0x8F, 0x99, 0x05, 0x66],
6: [0xEA, 0x0C, 0x81, 0x13, 0x63, 0xD7, 0xE9, 0x30, 0xF9, 0x61, 0x13, 0x5A, 0x4F, 0x35, 0x2D, 0xDC],
8: [0x0A, 0x2E, 0x73, 0x30, 0x5C, 0x38, 0x2D, 0x4F, 0x31, 0x0D, 0x0A, 0xED, 0x84, 0xA4, 0x18, 0x00],
0xA: [0xAC, 0x00, 0xC0, 0xE3, 0xE8, 0x0A, 0xF0, 0x68, 0x3F, 0xDD, 0x17, 0x45, 0x19, 0x45, 0x43, 0xBD],
0xD: [0xDF, 0xF3, 0xFC, 0xD6, 0x08, 0xB0, 0x55, 0x97, 0xCF, 0x09, 0xA2, 0x3B, 0xD1, 0x7D, 0x3F, 0xD2],
0xD9: [0xC7, 0xAC, 0x13, 0x06, 0xDE, 0xFE, 0x39, 0xEC, 0x83, 0xA1, 0x48, 0x3B, 0x0E, 0xE2, 0xEC, 0x89],
0x97: [0xCA, 0xC8, 0xB8, 0x7A, 0xCD, 0x9E, 0xC4, 0x96, 0x90, 0xAB, 0xE0, 0x81, 0x39, 0x20, 0xB1, 0x10],
0x2F: [0x4A, 0xA7, 0xC7, 0xB0, 0x11, 0x34, 0x46, 0x6F, 0xAC, 0x82, 0x16, 0x3E, 0x4B, 0xB5, 0x1B, 0xF9],
0xEB: [0x41, 0x84, 0x99, 0xBE, 0x9D, 0x35, 0xA3, 0xB9, 0xFC, 0x6A, 0xD0, 0xD6, 0xF0, 0x41, 0xBB, 0x26],
0xB3: [0x03, 0xBE, 0xB6, 0x54, 0x99, 0x14, 0x04, 0x83, 0xBA, 0x18, 0x7A, 0x64, 0xEF, 0x90, 0x26, 0x1D]
} 



    



challenge1_secret = {
0: [0xD2, 0x07, 0x22, 0x53, 0xA4, 0xF2, 0x74, 0x68],
1: [0xF5, 0xD7, 0xD4, 0xB5, 0x75, 0xF0, 0x8E, 0x4E],
2: [0xB3, 0x7A, 0x16, 0xEF, 0x55, 0x7B, 0xD0, 0x89],
3: [0xCC, 0x69, 0x95, 0x81, 0xFD, 0x89, 0x12, 0x6C],
4: [0xA0, 0x4E, 0x32, 0xBB, 0xA7, 0x13, 0x9E, 0x46],
5: [0x49, 0x5E, 0x03, 0x47, 0x94, 0x93, 0x1D, 0x7B],
6: [0xB0, 0xB8, 0x09, 0x83, 0x39, 0x89, 0xFA, 0xE2],
8: [0xAD, 0x40, 0x43, 0xB2, 0x56, 0xEB, 0x45, 0x8B],
0xA: [0xC2, 0x37, 0x7E, 0x8A, 0x74, 0x09, 0x6C, 0x5F],
0xD: [0x58, 0x1C, 0x7F, 0x19, 0x44, 0xF9, 0x62, 0x62],
0xD9: [0x90, 0xE1, 0xF0, 0xC0, 0x01, 0x78, 0xE3, 0xFF],
0x97: [0xAF, 0x60, 0x10, 0xA8, 0x46, 0xF7, 0x41, 0xF3],
0x2F: [0xF1, 0xBC, 0x56, 0x2B, 0xD5, 0x5B, 0xB0, 0x77],
0xEB: [0x0B, 0xD9, 0x02, 0x7E, 0x85, 0x1F, 0xA1, 0x23],
0xB3: [0xDB, 0xD3, 0xAE, 0xA4, 0xDB, 0x04, 0x64, 0x10 ]

}

challenge2_secret = {
0: [0xF4, 0xE0, 0x43, 0x13, 0xAD, 0x2E, 0xB4, 0xDB],
1: [0xFE, 0x7D, 0x78, 0x99, 0xBF, 0xEC, 0x47, 0xC5],
2: [0x86, 0x5E, 0x3E, 0xEF, 0x9D, 0xFB, 0xB1, 0xFD],
3: [0x30, 0x6F, 0x3A, 0x03, 0xD8, 0x6C, 0xBE, 0xE4],
4: [0xFF, 0x72, 0xBD, 0x2B, 0x83, 0xB8, 0x9D, 0x2F],
5: [0x84, 0x22, 0xDF, 0xEA, 0xE2, 0x1B, 0x63, 0xC2],
6: [0x58, 0xB9, 0x5A, 0xAE, 0xF3, 0x99, 0xDB, 0xD0],
8: [0x67, 0xC0, 0x72, 0x15, 0xD9, 0x6B, 0x39, 0xA1],
0xA: [0x09, 0x3E, 0xC5, 0x19, 0xAF, 0x0F, 0x50, 0x2D],
0xD: [0x31, 0x80, 0x53, 0x87, 0x5C, 0x20, 0x3E, 0x24],
0xD9: [0xC3, 0x4A, 0x6A, 0x7B, 0x20, 0x5F, 0xE8, 0xF9],
0x97: [0x9D, 0xEE, 0xC0, 0x11, 0x44, 0xB6, 0x6F, 0x41],
0x2F: [0x1B, 0xDF, 0x24, 0x33, 0xEB, 0x29, 0x15, 0x5B],
0xEB: [0xF7, 0x91, 0xED, 0x0B, 0x3F, 0x49, 0xA4, 0x48],
0xB3: [0xE3, 0x2B, 0x8F, 0x56, 0xB2, 0x64, 0x12, 0x98]
    
}
    
go_key1 = bytes.fromhex("C66E9ED6ECBCB121B7465D25037D6646")
go_key2 = bytes.fromhex("da24dab43a61cbdf61fd255d0aea7957")
go_secret = bytes.fromhex("880e2a94110926b20e53e22ae648ae9d")

def MixChallenge1(version, challenge):
    
    data = [ 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0]
    secret1=challenge1_secret[version]
    data[0] =secret1[0]
    data[4] =secret1[1]
    data[8] =secret1[2]
    data[0xC] =secret1[3]
    data[1] =secret1[4]
    data[5] =secret1[5]
    data[9] =secret1[6]
    data[0xD] =secret1[7]
    data[2] = challenge[0]
    data[6] = challenge[1]
    data[0xA] = challenge[2]
    data[0xE] = challenge[3]
    data[3] = challenge[4]
    data[7] = challenge[5]
    data[0xB] = challenge[6]
    data[0xF] = challenge[7]
    return data


def MixChallenge2(version, challenge):

    data = [ 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0]
    secret2=challenge2_secret[version]
    data[0] =challenge[0]
    data[4] =challenge[1]
    data[8] =challenge[2]
    data[0xC] =challenge[3]
    data[1] =challenge[4]
    data[5] =challenge[5]
    data[9] =challenge[6]
    data[0xD] =challenge[7]
    data[2] = secret2[0]
    data[6] = secret2[1]
    data[0xA] = secret2[2]
    data[0xE] = secret2[3]
    data[3] = secret2[4]
    data[7] = secret2[5]
    data[0xB] = secret2[6]
    data[0xF] = secret2[7]
    return data


       

newmap = [
    0x00, 0x04, 0x08, 0x0C, 0x01, 0x05, 0x09, 0x0D, 0x02, 0x06, 0x0A, 0x0E, 0x03, 0x07, 0x0B, 0x0F, 
]



def MatrixSwap(key):
    temp = [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0]
    for i in range(0,len(key)):
        temp[i] = key[newmap[i]]
    return temp[0:len(key)]


def xorloop(a,b):
    #x =bytearray()
    #x.append(b[:])
    #print('-> data: ' + bytes(b).hex().upper())
    x=bytearray()
    for i in range (0,len(b)):
        x.append( b[i]^ a[i])
    return x

 
def generateKeys(ea790,ea798,ea7C0,challenge):
    keyseed2 = [0x0B, 0x23, 0x85, 0x01, 0x0F, 0xB2, 0x79, 0xBD]
    keyseed3 = [0xE1, 0xC3, 0xEC, 0xA9, 0x19, 0x59, 0x04, 0x0D]
    
    mixkey2 = bytes(ea790) + bytes(keyseed2)
    mixkey1 = bytes(keyseed3) + bytes(ea798)
    
    xorkey = AES.new(mixkey1, AES.MODE_ECB).encrypt(bytes(ea7C0))
    chal1 = xorloop(xorkey,bytes(challenge))
    chal2 =  AES.new(mixkey1, AES.MODE_ECB).encrypt(chal1)
    finalkey = AES.new(mixkey2, AES.MODE_ECB).encrypt(xorkey)
    chal3 = AES.new(mixkey2, AES.MODE_ECB).encrypt(chal2)    
    finalchal = xorloop(chal3,xorkey)
    return (finalkey,finalchal)
    
def main():
    
    #Just a test
    chal97 =  [0x66, 0x1A, 0x4D, 0x7F, 0x6E, 0xCD, 0x33, 0xC5, 0x2B, 0xF5, 0xF2, 0x95, 0x86, 0xA7, 0x64, 0x48]
    chal2F = [0xC9, 0xF8, 0x09, 0x45, 0x2A, 0xA2, 0xBE, 0xD5, 0x40, 0xD0, 0x2B, 0xAC, 0xFB, 0x1A, 0x8B, 0xEA]
    
    ea7c0seed97 = [ 0xA0, 0x40, 0x27, 0x97, 0xD8, 0xBE, 0x73, 0x4E, 0x3C, 0x76, 0x1D, 0x67, 0x1F, 0x04, 0x1E, 0x20]
    ea7c0seed2F = [ 0x1D, 0xF0, 0x78, 0x9A, 0x5F, 0x45, 0x02, 0x1A, 0x98, 0xCE, 0xE9, 0xAB, 0x54, 0x45, 0x6C, 0xEE] 
    ea790key =  [0x8B, 0xA2, 0xA9, 0xBB, 0x32, 0xF8, 0x10, 0x07]
    ea798key =  [0xE5, 0x8D, 0x22, 0x1F, 0xFF, 0x58, 0xC2, 0x46]
    (key,chal) = generateKeys(ea790key,ea798key,ea7c0seed97,chal97)
    #print('97 Key:       ' + bytes(key).hex().upper())
    #print('97 Challenge: ' + bytes(chal).hex().upper())

    (key,chal) = generateKeys(ea790key,ea798key,ea7c0seed2F,chal2F)
    #print('2F Key:       ' + bytes(key).hex().upper())
    #print('2F Challenge: ' + bytes(chal).hex().upper())


    screq=bytes.fromhex(input("Syscon Challenge 1(9 bytes, first byte is version):"))


    if(len(screq) != 9):
        print("Error! Expecting a 0x80 type challenge message of length 9 (i.e. 02D65C94ABB92E5DBA)\n")
        return
        
    version= screq[0]
    req = screq[1:]
    
    print('-> Syscon Challenge 1: 0B 80 ' + bytes(screq).hex().upper())
    
    # The first challenge mixes the syscon generated challenge and the first challenge secret
    data=MixChallenge1(version,req)
    
    # The first challenge has two encryption, one for the first half and one for the second half
    challenge1a=AES.new(bytes(keystore[version]), AES.MODE_ECB).encrypt(bytes(MatrixSwap(data)))
    #print("Challenge1a: " +(bytes( challenge1a).hex().upper()))
    #second = bytearray(0x10)
    #second[:] = challenge1a[:]
    
    #hallenge1b=MatrixSwap(AES.new(bytes(keystore[version]), AES.MODE_ECB).encrypt(bytes((second))))
    #print("Challenge1b: " +(bytes( challenge1b).hex().upper()))
    challenge1b = randbytes(8) #bytearray.fromhex('F9D3034A30FEDBB5') #1816CA74BF41A6CFF9D3034A30FEDBB5
    response1 = bytes(challenge1a[0:8]) + bytes(challenge1b[0:8])
        
    print('<- Jig Response 1: 12 06 ' + bytes(response1).hex().upper())
    
    # The second challenge only uses the half of the first challenge and the second challenge secret
    data2=MixChallenge2(version,challenge1b[0:8])
    #data2=MixChallenge2(version,cb)
    challenge2=AES.new(bytes(keystore[version]), AES.MODE_ECB).encrypt(bytes(MatrixSwap(data2)))
    
    print('-> Syscon Challenge 2: 0A 81 ' + bytes(challenge2[0:8]).hex().upper())
    
    response2=(AES.new(bytes(keystore[version]), AES.MODE_ECB).encrypt(challenge2))
    
    print('<- Jig Response 2: 0A 06 ' + bytes(response2[0:8]).hex().upper())

    if version in (0xEB, 0xB3):
        screq=bytes.fromhex(input("Syscon Challenge 2(0x28 bytes):"))
        print('-> Syscon Go Challenge 90: 2A 90 ' + bytes(screq).hex().upper())

        payload=AES.new(go_key1, AES.MODE_CBC, bytearray(0x10)).decrypt(screq[0x8:0x28])
        print('Decrypted result: ' + payload.hex().upper())
        payload91 = payload[8:0x10] + payload[0:8]
        if payload[0x10:0x20] == go_secret:
            print("Go Handshake Request is valid")
        else:
            print("Invalid request from Syscon")
            return
        resp2 = AES.new(go_key2, AES.MODE_CBC, bytearray(0x10)).decrypt(payload91)
        print('<- Jig Response 91: 2A 06 2001000682828282' + resp2.hex().upper())
    
if __name__ == "__main__":
    main()
